import json
import logging
import re
import urllib.request
from pathlib import Path
from textwrap import dedent

log = logging.getLogger()

ROOT_DIR = Path(__file__).parent.parent
GENERATED_TOOLS_DIR = ROOT_DIR / "src" / "tapir_archicad_mcp" / "tools" / "generated"

COMMAND_DETAILS_URL = "https://raw.githubusercontent.com/SzamosiMate/multiconn_archicad/main/code_generation/schema/_command_details.json"

FILE_HEADER = "# This file is auto-generated by generate_tools.py. DO NOT EDIT."

DOCSTRING_TEMPLATE = '''"""
    {description}

    To find a valid 'port' number, use the 'tapir_discovery_list_active_archicads' tool.
    """'''


def camel_to_snake(name: str) -> str:
    """Converts a CamelCase string to a pythonic_snake_case string."""
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()


def get_command_model_names(command_name: str) -> tuple[str, str]:
    """Generates the Pydantic model names for a command's parameters and result."""
    return f"{command_name}Parameters", f"{command_name}Result"


def fetch_command_details(url: str) -> list[dict]:
    """
    Fetches the command details JSON from the provided URL.
    """
    log.info(f"Fetching command details from {url}...")
    try:
        with urllib.request.urlopen(url) as response:
            if response.status == 200:
                return json.loads(response.read().decode("utf-8"))
            else:
                raise ConnectionError(f"Failed to fetch file: HTTP {response.status}")
    except urllib.request.HTTPError as e:
        log.error(f"Failed to fetch command details: {e}")
        return []


def group_commands_by_category(command_details: list[dict]) -> dict[str, list[dict]]:
    """
    Groups command detail dictionaries by their 'group' key.
    """
    grouped = {}
    for cmd in command_details:
        group_key = cmd["group"].replace(" ", "_").lower()
        if group_key not in grouped:
            grouped[group_key] = []
        grouped[group_key].append(cmd)
    log.info(f"Grouped {len(command_details)} commands into {len(grouped)} categories.")
    return grouped


def prepare_output_directory(path: Path):
    """
    Ensures the output directory is clean before generation.
    """
    if path.exists():
        log.warning(f"Output directory {path} exists. Cleaning...")
        for f in path.glob("*.py"):
            f.unlink()
    else:
        path.mkdir(parents=True)
    log.info(f"Prepared generation directory: {path}")


def _generate_imports_for_group(commands: list[dict]) -> str:
    """Generates the required import block for a set of commands."""
    imports = set()
    for cmd in commands:
        p_model, r_model = get_command_model_names(cmd["name"])
        imports.add(p_model)
        imports.add(r_model)

    import_statements = ",\n".join(f"    {imp}" for imp in sorted(list(imports)))
    return dedent(f"""
    from multiconn_archicad.models.commands import (
    {import_statements},
    )
    """)


def _generate_tool_function_code(command: dict) -> str:
    """Generates the full Python code for a single MCP tool function."""
    command_name_camel = command["name"]
    command_name_snake = camel_to_snake(command_name_camel)
    group_name_snake = command["group"].replace(" ", "_").lower()
    tool_name = f"tapir_{group_name_snake}_{command_name_snake}"

    params_model, result_model = get_command_model_names(command_name_camel)

    # Handle commands that might not have a specific result model (return None)
    return_annotation = result_model
    try:
        # Check if the result model actually exists in the commands module
        from multiconn_archicad.models import commands
        getattr(commands, result_model)
        return_statement = f"return {result_model}.model_validate(result_dict)"
    except AttributeError:
        return_annotation = "None"
        return_statement = "return None"

    docstring = DOCSTRING_TEMPLATE.format(description=command["description"])

    return dedent(f'''
    @mcp.tool(
        name="{tool_name}",
        title="{command_name_camel}",
        description="{command["description"]}"
    )
    def {command_name_snake}(port: int, params: {params_model}) -> {return_annotation}:
        {docstring}
        log.info(f"Executing {command_name_snake} tool on port {{port}}")
        multi_conn = multi_conn_instance.get()

        target_port = Port(port)
        if target_port not in multi_conn.active:
            raise ValueError(f"Port {{port}} is not an active Archicad connection.")

        conn_header = multi_conn.active[target_port]

        try:
            result_dict = conn_header.core.post_tapir_command(
                command="{command_name_camel}",
                parameters=params.model_dump()
            )
            {return_statement}
        except ValidationError as e:
            log.error(f"Validation error for {command_name_camel} result: {{e}}")
            raise ValueError(f"Received an invalid response from the Archicad API: {{e}}")
        except Exception as e:
            log.error(f"Error executing {command_name_camel} on port {{port}}: {{e}}")
            raise e
    ''')


def generate_tool_files(grouped_commands: dict[str, list[dict]], out_dir: Path):
    """Generates a .py file for each command group, containing all related tools."""
    for group_name, commands in grouped_commands.items():
        file_path = out_dir / f"{group_name}.py"

        imports_block = _generate_imports_for_group(commands)

        file_content = [
            FILE_HEADER,
            "",
            "import logging",
            "from pydantic import ValidationError",
            "",
            "from tapir_archicad_mcp.app import mcp",
            "from tapir_archicad_mcp.context import multi_conn_instance",
            "from multiconn_archicad.basic_types import Port",
            imports_block,
            "log = logging.getLogger()",
        ]

        for cmd in commands:
            file_content.append(_generate_tool_function_code(cmd))

        with open(file_path, "w", encoding="utf-8") as f:
            f.write("\n".join(file_content))
        log.info(f"Generated tool file: {file_path}")


def generate_init_file(grouped_commands: dict[str, list[dict]], out_dir: Path):
    """Generates the __init__.py file to make the directory a package."""
    init_path = out_dir / "__init__.py"
    content = [
        FILE_HEADER,
        "# This file makes the 'generated' directory a package and allows for easy importing.",
        ""
    ]
    for group_name in sorted(grouped_commands.keys()):
        content.append(f"from .{group_name} import *")

    with open(init_path, "w", encoding="utf-8") as f:
        f.write("\n".join(content))
    log.info(f"Generated __init__.py file at {init_path}")


def main():
    """Main execution function to run the entire generation process."""
    log.info("--- Starting Archicad MCP Tool Generator ---")

    command_details = fetch_command_details(COMMAND_DETAILS_URL)
    if not command_details:
        log.critical("Could not fetch command details. Aborting generation.")
        return

    grouped_commands = group_commands_by_category(command_details)

    prepare_output_directory(GENERATED_TOOLS_DIR)
    generate_tool_files(grouped_commands, GENERATED_TOOLS_DIR)
    generate_init_file(grouped_commands, GENERATED_TOOLS_DIR)

    log.info("--- Tool Generation Completed Successfully ---")


if __name__ == "__main__":
    main()